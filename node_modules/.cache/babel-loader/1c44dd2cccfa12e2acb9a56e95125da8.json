{"ast":null,"code":"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\nimport { exitThunk } from './userAPI';\nimport { JWT_EXPIRE, REFRESH_TOKEN, TOKEN } from '../variables/localStorageVariables';\nconst baseQuery = fetchBaseQuery({\n  //const token = (getState() as RootState).userToken;\n  baseUrl: 'http://localhost:3002/vocabulary',\n  prepareHeaders: headers => {\n    headers.set('Authorization', `Bearer ${localStorage.getItem(TOKEN) || 'unknown'} ${localStorage.getItem(REFRESH_TOKEN) || 'unknown'}`);\n    return headers;\n  }\n});\nconst baseQueryWithReauth = async (args, api, extraOptions) => {\n  var _result$error, _result$error2;\n  let result = await baseQuery(args, api, extraOptions);\n  if (((_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.originalStatus) === 401 || ((_result$error2 = result.error) === null || _result$error2 === void 0 ? void 0 : _result$error2.status) === 401) {\n    const refresh = await fetch('http://localhost:3002/refreshToken', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json;charset=utf-8'\n      },\n      body: JSON.stringify({\n        refreshToken: localStorage.getItem(REFRESH_TOKEN)\n      })\n    });\n    if (refresh.status === 200) {\n      const data = await refresh.json();\n      console.log('Токены получены. Перезапускаю функцию', data);\n      localStorage.setItem(TOKEN, data.token);\n      localStorage.setItem(REFRESH_TOKEN, data.refresh_token);\n      localStorage.setItem(JWT_EXPIRE, data.jwt_expire);\n      return await baseQuery(args, api, extraOptions);\n    } else {\n      console.log('Ошибка токена. Диспатчу exitThunk()');\n      api.dispatch(exitThunk());\n    }\n  }\n  return result;\n};\nexport const vocabularyAPI = createApi({\n  reducerPath: 'vocabularyApi',\n  baseQuery: baseQueryWithReauth,\n  tagTypes: ['vocabulary'],\n  endpoints: builder => ({\n    getVocabulary: builder.query({\n      query: id => `/${id}`,\n      providesTags: (result, error, id) => [{\n        type: 'vocabulary',\n        id\n      }]\n    }),\n    getUnlerned: builder.query({\n      //может надо разбить на отдельные методы лучше\n      query: req => `/${req.userId}/unlerned/${req.method}/group/${req.groupId}`,\n      providesTags: (result, error, id) => [{\n        type: 'vocabulary',\n        id\n      }]\n    }),\n    getUnlernedSpell: builder.query({\n      //может надо разбить на отдельные методы лучше\n      query: req => `/${req.userId}/unlerned/spelling/group/${req.groupId}`,\n      providesTags: (result, error, id) => [{\n        type: 'vocabulary',\n        id\n      }],\n      transformResponse: resp => ({\n        ...resp,\n        trueVariant: resp.eng,\n        eng: resp.eng.toUpperCase().split('').sort(() => Math.random() - 0.5).join('')\n      })\n    }),\n    setVocabulary: builder.mutation({\n      query: body => ({\n        url: `/${body.userId}/${body.method}`,\n        method: 'PUT',\n        body\n      }),\n      invalidatesTags: ['vocabulary']\n    }),\n    getGroupProgess: builder.query({\n      query: body => `groups/${body.groupId}/progress/${body.userId === 0 ? 1 : body.userId}`,\n      //Надо обработать ошибку нормально\n      providesTags: ['vocabulary'],\n      transformErrorResponse: (resp, meta, arg) => {\n        console.log('ara', resp, meta, arg);\n        return resp;\n      }\n    })\n  })\n});\nexport const {\n  useGetVocabularyQuery,\n  useSetVocabularyMutation,\n  useGetUnlernedQuery,\n  useGetUnlernedSpellQuery,\n  useGetGroupProgessQuery\n} = vocabularyAPI;","map":{"version":3,"names":["createApi","fetchBaseQuery","exitThunk","JWT_EXPIRE","REFRESH_TOKEN","TOKEN","baseQuery","baseUrl","prepareHeaders","headers","set","localStorage","getItem","baseQueryWithReauth","args","api","extraOptions","result","error","originalStatus","status","refresh","fetch","method","body","JSON","stringify","refreshToken","data","json","console","log","setItem","token","refresh_token","jwt_expire","dispatch","vocabularyAPI","reducerPath","tagTypes","endpoints","builder","getVocabulary","query","id","providesTags","type","getUnlerned","req","userId","groupId","getUnlernedSpell","transformResponse","resp","trueVariant","eng","toUpperCase","split","sort","Math","random","join","setVocabulary","mutation","url","invalidatesTags","getGroupProgess","transformErrorResponse","meta","arg","useGetVocabularyQuery","useSetVocabularyMutation","useGetUnlernedQuery","useGetUnlernedSpellQuery","useGetGroupProgessQuery"],"sources":["/Users/tatanaarhipova/MikeIT/eng/src/app/API/vocabularyAPI.tsx"],"sourcesContent":["import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Progress, Word } from '../types/types'\nimport type { BaseQueryFn, FetchArgs, FetchBaseQueryError } from '@reduxjs/toolkit/query'\nimport { exitThunk } from './userAPI';\nimport { JWT_EXPIRE, REFRESH_TOKEN, TOKEN } from '../variables/localStorageVariables';\n\nconst baseQuery = fetchBaseQuery({ \n    //const token = (getState() as RootState).userToken;\n    baseUrl: 'http://localhost:3002/vocabulary',\n    prepareHeaders: (headers: Headers) => {\n      headers.set('Authorization', `Bearer ${localStorage.getItem(TOKEN) || 'unknown' } ${localStorage.getItem(REFRESH_TOKEN) || 'unknown'}`)\n      return headers\n    }\n   })\nconst baseQueryWithReauth: BaseQueryFn<string | FetchArgs, unknown, FetchBaseQueryError> = async (args, api, extraOptions) => {\n    let result = await baseQuery(args, api, extraOptions)\n    if(result.error?.originalStatus === 401 || result.error?.status === 401){\n        const refresh = await fetch('http://localhost:3002/refreshToken', {         \n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json;charset=utf-8'\n            }, \n            body: JSON.stringify({\n                refreshToken: localStorage.getItem(REFRESH_TOKEN)\n            })\n        })\n        if(refresh.status === 200){\n            const data = await refresh.json()   \n            console.log('Токены получены. Перезапускаю функцию', data)\n            localStorage.setItem(TOKEN, data.token)\n            localStorage.setItem(REFRESH_TOKEN, data.refresh_token)\n            localStorage.setItem(JWT_EXPIRE, data.jwt_expire)\n            return await baseQuery(args, api, extraOptions)\n        } else{\n            console.log('Ошибка токена. Диспатчу exitThunk()')\n            api.dispatch(exitThunk())\n        }\n    }\n    return result\n}\ntype QueryBody = {\n    groupId: number | string, \n    userId: number | string\n}\nexport const vocabularyAPI = createApi({\n    reducerPath: 'vocabularyApi',\n    baseQuery: baseQueryWithReauth,\n    tagTypes: ['vocabulary'],\n    endpoints: (builder) => ({\n        getVocabulary: builder.query<any, any>({\n            query: (id: number) =>  `/${id}`,\n            providesTags: (result, error, id) => [{ type: 'vocabulary', id }],\n        }),\n        getUnlerned: builder.query<any, any>({ //может надо разбить на отдельные методы лучше\n            query: (req) =>  `/${req.userId}/unlerned/${req.method}/group/${req.groupId}`,\n            providesTags: (result, error, id) => [{ type: 'vocabulary', id }],\n        }),\n        getUnlernedSpell: builder.query<any, any>({ //может надо разбить на отдельные методы лучше\n            query: (req) =>  `/${req.userId}/unlerned/spelling/group/${req.groupId}`,\n            providesTags: (result, error, id) => [{ type: 'vocabulary', id }],\n            transformResponse: (resp: Word) => ({...resp, trueVariant: resp.eng, eng: resp.eng.toUpperCase().split('').sort(() => Math.random() - 0.5).join('')})\n        }),\n        setVocabulary: builder.mutation<any, {method: string, word_id: number, userId: number}>({\n            query: (body) => ({\n                url: `/${body.userId}/${body.method}`,\n                method: 'PUT',\n                body\n            }),\n            invalidatesTags: ['vocabulary']\n        }),\n        getGroupProgess: builder.query<Progress, QueryBody>({\n            query: (body) =>  `groups/${body.groupId}/progress/${body.userId === 0 ? 1 : body.userId}`, //Надо обработать ошибку нормально\n            providesTags: ['vocabulary'], \n            transformErrorResponse: (resp: any, meta, arg) => {\n                console.log('ara', resp, meta, arg)\n                return resp\n            }\n        }),\n    })\n})\n\nexport const { useGetVocabularyQuery, useSetVocabularyMutation, useGetUnlernedQuery, useGetUnlernedSpellQuery, useGetGroupProgessQuery } = vocabularyAPI"],"mappings":"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"},"metadata":{},"sourceType":"module"}