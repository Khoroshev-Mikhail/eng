{"ast":null,"code":"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';\nimport { exitThunk } from './userAPI';\nimport { JWT_EXPIRE, REFRESH_TOKEN, TOKEN } from '../consts';\nconst baseQuery = fetchBaseQuery({\n  //const token = (getState() as RootState).userToken;\n  baseUrl: 'http://localhost:3002/vocabulary',\n  prepareHeaders: headers => {\n    console.log('токены при запросе', localStorage.getItem(TOKEN), localStorage.getItem(REFRESH_TOKEN));\n    headers.set('Authorization', `Bearer ${localStorage.getItem(TOKEN) || 'unknown'} ${localStorage.getItem(REFRESH_TOKEN) || 'unknown'}`);\n    return headers;\n  }\n});\nconst baseQueryWithReauth = async (args, api, extraOptions) => {\n  var _result$error, _result$error2;\n  let result = await baseQuery(args, api, extraOptions);\n  if (((_result$error = result.error) === null || _result$error === void 0 ? void 0 : _result$error.originalStatus) === 401 || ((_result$error2 = result.error) === null || _result$error2 === void 0 ? void 0 : _result$error2.status) === 401) {\n    const refresh = await fetch('http://localhost:3002/refreshToken', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json;charset=utf-8'\n      },\n      body: JSON.stringify({\n        refreshToken: localStorage.getItem(REFRESH_TOKEN)\n      })\n    });\n    if (refresh.status === 200) {\n      const data = await refresh.json();\n      console.log('Токены получены. Перезапускаю функцию', data);\n      localStorage.setItem(TOKEN, data.token);\n      localStorage.setItem(REFRESH_TOKEN, data.refresh_token);\n      localStorage.setItem(JWT_EXPIRE, data.jwt_expire);\n      return await baseQuery(args, api, extraOptions);\n    } else {\n      console.log('Ошибка токена. Диспатчу exitThunk()');\n      api.dispatch(exitThunk());\n    }\n  }\n  return result;\n};\nexport const vocabularyAPI = createApi({\n  reducerPath: 'vocabularyApi',\n  baseQuery: baseQueryWithReauth,\n  tagTypes: ['vocabulary'],\n  endpoints: builder => ({\n    getVocabulary: builder.query({\n      query: id => `/${id}`,\n      providesTags: (result, error, id) => [{\n        type: 'vocabulary',\n        id\n      }]\n    }),\n    getUnlerned: builder.query({\n      //может надо разбить на отдельные методы лучше\n      query: req => `/${req.userId}/unlerned/${req.method}/group/${req.groupId}`,\n      providesTags: (result, error, id) => [{\n        type: 'vocabulary',\n        id\n      }]\n    }),\n    getUnlernedSpell: builder.query({\n      //может надо разбить на отдельные методы лучше\n      query: req => `/${req.userId}/unlerned/spelling/group/${req.groupId}`,\n      providesTags: (result, error, id) => [{\n        type: 'vocabulary',\n        id\n      }],\n      transformResponse: resp => ({\n        ...resp,\n        trueVariant: resp.eng,\n        eng: resp.eng.toUpperCase().split('').sort(() => Math.random() - 0.5).join('')\n      })\n    }),\n    setVocabulary: builder.mutation({\n      query: body => ({\n        url: `/${body.userId}/${body.method}`,\n        method: 'PUT',\n        body\n      }),\n      invalidatesTags: ['vocabulary']\n    }),\n    getGroupProgess: builder.query({\n      query: body => `groups/${body.groupId}/progress/${body.userId}`,\n      providesTags: ['vocabulary']\n    })\n  })\n});\nexport const {\n  useGetVocabularyQuery,\n  useSetVocabularyMutation,\n  useGetUnlernedQuery,\n  useGetUnlernedSpellQuery,\n  useGetGroupProgessQuery\n} = vocabularyAPI;","map":{"version":3,"names":["createApi","fetchBaseQuery","exitThunk","JWT_EXPIRE","REFRESH_TOKEN","TOKEN","baseQuery","baseUrl","prepareHeaders","headers","console","log","localStorage","getItem","set","baseQueryWithReauth","args","api","extraOptions","result","error","originalStatus","status","refresh","fetch","method","body","JSON","stringify","refreshToken","data","json","setItem","token","refresh_token","jwt_expire","dispatch","vocabularyAPI","reducerPath","tagTypes","endpoints","builder","getVocabulary","query","id","providesTags","type","getUnlerned","req","userId","groupId","getUnlernedSpell","transformResponse","resp","trueVariant","eng","toUpperCase","split","sort","Math","random","join","setVocabulary","mutation","url","invalidatesTags","getGroupProgess","useGetVocabularyQuery","useSetVocabularyMutation","useGetUnlernedQuery","useGetUnlernedSpellQuery","useGetGroupProgessQuery"],"sources":["/Users/tatanaarhipova/MikeIT/eng/src/app/API/vocabularyAPI.tsx"],"sourcesContent":["import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\nimport type { Word } from '../types/types'\nimport type { BaseQueryFn, FetchArgs, FetchBaseQueryError } from '@reduxjs/toolkit/query'\nimport { exitThunk } from './userAPI';\nimport { JWT_EXPIRE, REFRESH_TOKEN, TOKEN } from '../consts';\n\nconst baseQuery = fetchBaseQuery({ \n    //const token = (getState() as RootState).userToken;\n    baseUrl: 'http://localhost:3002/vocabulary',\n    prepareHeaders: (headers: Headers) => {\n      console.log('токены при запросе', localStorage.getItem(TOKEN), localStorage.getItem(REFRESH_TOKEN))\n      headers.set('Authorization', `Bearer ${localStorage.getItem(TOKEN) || 'unknown' } ${localStorage.getItem(REFRESH_TOKEN) || 'unknown'}`)\n      return headers\n    }\n   })\nconst baseQueryWithReauth: BaseQueryFn<string | FetchArgs, unknown, FetchBaseQueryError> = async (args, api, extraOptions) => {\n    let result = await baseQuery(args, api, extraOptions)\n    if(result.error?.originalStatus === 401 || result.error?.status === 401){\n        const refresh = await fetch('http://localhost:3002/refreshToken', {         \n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json;charset=utf-8'\n            }, \n            body: JSON.stringify({\n                refreshToken: localStorage.getItem(REFRESH_TOKEN)\n            })\n        })\n        if(refresh.status === 200){\n            const data = await refresh.json()   \n            console.log('Токены получены. Перезапускаю функцию', data)\n            localStorage.setItem(TOKEN, data.token)\n            localStorage.setItem(REFRESH_TOKEN, data.refresh_token)\n            localStorage.setItem(JWT_EXPIRE, data.jwt_expire)\n            return await baseQuery(args, api, extraOptions)\n        } else{\n            console.log('Ошибка токена. Диспатчу exitThunk()')\n            api.dispatch(exitThunk())\n        }\n    }\n    return result\n}\n\nexport const vocabularyAPI = createApi({\n    reducerPath: 'vocabularyApi',\n    baseQuery: baseQueryWithReauth,\n    tagTypes: ['vocabulary'],\n    endpoints: (builder) => ({\n        getVocabulary: builder.query<any, any>({\n            query: (id: number) =>  `/${id}`,\n            providesTags: (result, error, id) => [{ type: 'vocabulary', id }],\n        }),\n        getUnlerned: builder.query<any, any>({ //может надо разбить на отдельные методы лучше\n            query: (req) =>  `/${req.userId}/unlerned/${req.method}/group/${req.groupId}`,\n            providesTags: (result, error, id) => [{ type: 'vocabulary', id }],\n        }),\n        getUnlernedSpell: builder.query<any, any>({ //может надо разбить на отдельные методы лучше\n            query: (req) =>  `/${req.userId}/unlerned/spelling/group/${req.groupId}`,\n            providesTags: (result, error, id) => [{ type: 'vocabulary', id }],\n            transformResponse: (resp: Word) => ({...resp, trueVariant: resp.eng, eng: resp.eng.toUpperCase().split('').sort(() => Math.random() - 0.5).join('')})\n        }),\n        setVocabulary: builder.mutation<any, {method: string, word_id: number, userId: number}>({\n            query: (body) => ({\n                url: `/${body.userId}/${body.method}`,\n                method: 'PUT',\n                body\n            }),\n            invalidatesTags: ['vocabulary']\n        }),\n        getGroupProgess: builder.query<{english: number, russian: number, spelling: number, auding: number}, {groupId: number, userId: number}>({\n            query: (body) =>  `groups/${body.groupId}/progress/${body.userId}`,\n            providesTags: ['vocabulary'], \n        }),\n    })\n})\n\nexport const { useGetVocabularyQuery, useSetVocabularyMutation, useGetUnlernedQuery, useGetUnlernedSpellQuery, useGetGroupProgessQuery } = vocabularyAPI"],"mappings":"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"},"metadata":{},"sourceType":"module"}